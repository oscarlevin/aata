<?xml version="1.0"?>
<!-- This file is part of the book                    -->
<!--                                                  -->
<!-- Abstract Algebra: Theory and Applications        -->
<!--                                                  -->
<!-- Text: Copyright (C) 1997-2018  Thomas W. Judson  -->
<!-- Sage: Copyright (C) 2010-2018  Robert A. Beezer  -->
<!-- See the file COPYING for copying conditions.     -->
<!-- This file is part of the book                    -->
<!--                                                  -->
<!-- See the file COPYING for copying conditions.     -->
<chapter xmlns:xi="http://www.w3.org/2001/XInclude" xml:id="crypt" permid="uCn">
  <title>Introduction to Cryptography</title>
  <introduction permid="YyK">
    <p permid="WCt">
      Cryptography is the study of sending and receiving secret messages.
      The aim of cryptography is to send messages across a channel so that only the intended recipient of the message can read it.
      In addition, when a message is received,
      the recipient usually requires some assurance that the message is authentic;
      that is, that it has not been sent by someone who is trying to deceive the recipient.
      Modern cryptography is heavily dependent on abstract algebra and number theory.
    </p>

    <p permid="CJC">
      The message to be sent is called the <term>plaintext</term>
          <idx><h>Plaintext</h></idx>
      message.
      The disguised message is called the <term>ciphertext</term>.
          <idx><h>Ciphertext</h></idx>
      The plaintext and the ciphertext are both written in an <term>alphabet</term>,
      consisting of <term>letters</term>
      or <term>characters</term>.
      Characters can include not only the familiar alphabetic characters A, <m>\ldots</m>, Z and a, <m>\ldots</m>,
      z but also digits, punctuation marks, and blanks.
      A <term>cryptosystem</term>,<idx><h>Cryptosystem</h><h>definition of</h></idx> or <term>cipher</term>,
          <idx><h>Cipher</h></idx>
      has two parts: <term>encryption</term>,
      the process of transforming a plaintext message to a ciphertext message,
      and <term>decryption</term>,
      the reverse transformation of changing a ciphertext message into a plaintext message.
    </p>

    <p permid="iQL">
      There are many different families of cryptosystems,
      each distinguished by a particular encryption algorithm.
      Cryptosystems in a specified cryptographic family are distinguished from one another by a parameter to the encryption function called a <term>key</term>.
          <idx><h>Key</h><h>definition of</h></idx>
      A classical cryptosystem has a single key,
      which must be kept secret,
      known only to the sender and the receiver of the message.
      If person <m>A</m> wishes to send secret messages to two different people <m>B</m> and <m>C</m>,
      and does not wish to have <m>B</m> understand <m>C</m>'s messages or vice versa,
      <m>A</m> must use two separate keys,
      so one cryptosystem is used for exchanging messages with <m>B</m>,
      and another is used for exchanging messages with <m>C</m>.
    </p>

    <p permid="OXU">
      Systems that use two separate keys,
      one for encoding and another for decoding,
      are called <term>public key cryptosystems</term>.
          <idx><h>Key</h><h>public</h></idx>
          <idx><h>Cryptosystem</h><h>public key</h></idx>
      Since knowledge of the encoding key does not allow anyone to guess at the decoding key,
      the encoding key can be made public.
      A public key cryptosystem allows <m>A</m> and <m>B</m> to send messages to <m>C</m> using the same encoding key.
      Anyone is capable of encoding a message to be sent to <m>C</m>,
      but only <m>C</m> knows how to decode such a message.
    </p>
  </introduction>

  <section xml:id="section-private-key-crypt" permid="Qkr">
    <title>Private Key Cryptography</title>
    <p permid="ztx">
      In <term>single</term>
          <idx><h>Key</h><h>single</h></idx>
          <idx><h>Cryptosystem</h><h>single key</h></idx>
      or <term>private key cryptosystems</term>
          <idx><h>Key</h><h>private</h></idx>
          <idx><h>Cryptosystem</h><h>private key</h></idx>
      the same key is used for both encrypting and decrypting messages.
      To encrypt a plaintext message,
      we apply to the message some function which is kept secret,
      say <m>f</m>.
      This function will yield an encrypted message.
      Given the encrypted form of the message,
      we can recover the original message by applying the inverse transformation <m>f^{-1}</m>.
      The transformation <m>f</m> must be relatively easy to compute,
      as must <m>f^{-1}</m>;
      however, <m>f</m> must be extremely difficult to guess from available examples of coded messages.
    </p>

    <example xml:id="example-crypt-caesar" permid="zWa">
      <p permid="RSA">
        One of the first and most famous private key cryptosystems was the shift code used by Julius Caesar.
        We first digitize the alphabet by letting <m>\text{A}  = 00, \text{B}  = 01, \ldots, \text{Z} = 25</m>.
        The encoding function will be
        <me permid="QrI">
          f(p) = p + 3 \bmod 26;
        </me>
        that is, <m>A \mapsto D, B \mapsto E, \ldots, Z \mapsto C</m>.
        The decoding function is then
        <me permid="wyR">
          f^{-1}(p) = p - 3 \bmod 26 = p + 23 \bmod 26
        </me>.
        Suppose we receive the encoded message DOJHEUD. To decode this message,
        we first digitize it:
        <me permid="cGa">
          3, 14, 9, 7, 4, 20, 3
        </me>.
        Next we apply the inverse transformation to get
        <me permid="INj">
          0, 11, 6, 4, 1, 17, 0
        </me>,
        or ALGEBRA. Notice here that there is nothing special about either of the numbers <m>3</m> or <m>26</m>.
        We could have used a larger alphabet or a different shift.
      </p>
    </example>

    <p permid="LHP">
      <term>Cryptanalysis</term>
          <idx><h>Cryptanalysis</h></idx>
      is concerned with deciphering a received or intercepted message.
      Methods from probability and statistics are great aids in deciphering an intercepted message;
      for example,
      the frequency analysis of the characters appearing in the intercepted message often makes its decryption possible.
    </p>

    <example xml:id="example-crypt-analysis" permid="gdj">
      <p permid="xZJ">
        Suppose we receive a message that we know was encrypted by using a shift transformation on single letters of the <m>26</m>-letter alphabet.
        To find out exactly what the shift transformation was,
        we must compute <m>b</m> in the equation <m>f(p) = p + b \bmod 26</m>.
        We can do this using frequency analysis.
        The letter <m>\text{E} = 04</m> is the most commonly occurring letter in the English language.
        Suppose that <m>\text{S} = 18</m> is the most commonly occurring letter in the ciphertext.
        Then we have good reason to suspect that  <m>18 = 4 + b \bmod 26</m>,
        or <m>b= 14</m>.
        Therefore, the most likely encrypting function is
        <me permid="oUs">
          f(p) = p + 14 \bmod 26
        </me>.
        The corresponding decrypting function is
        <me permid="VbB">
          f^{-1}(p) = p + 12 \bmod 26
        </me>.
        It is now easy to determine whether or not our guess is correct.
      </p>
    </example>

    <p permid="rOY">
      Simple shift codes are examples of
      <term>monoalphabetic cryptosystems</term>.
          <idx><h>Cryptosystem</h><h>monoalphabetic</h></idx>
      In these ciphers a character in the enciphered message represents exactly one character in the original message.
      Such cryptosystems are not very sophisticated and are quite easy to break.
      In fact, in a simple shift as described in <xref ref="example-crypt-caesar"/>, there are only <m>26</m> possible keys.
      It would be quite easy to try them all rather than to use frequency analysis.
    </p>

    <p permid="XWh">
      Let us investigate a slightly more sophisticated cryptosystem.
      Suppose that the encoding function is given by
      <me permid="BiK">
        f(p) = ap + b \bmod 26
      </me>.
      We first need to find out when a decoding function <m>f^{-1}</m> exists.
      Such a decoding function exists when we can solve the equation
      <me permid="hpT">
        c = ap + b \bmod 26
      </me>
      for <m>p</m>.
      By <xref ref="proposition-zn-equiv-classes"/>,
      this is possible exactly when <m>a</m> has an inverse or,
      equivalently, when <m>\gcd( a, 26) =1</m>.
      In this case
      <me permid="Nxc">
        f^{-1}(p) = a^{-1} p - a^{-1} b \bmod 26
      </me>.
      Such a cryptosystem is called an
      <term>affine cryptosystem</term>.
          <idx><h>Cryptosystem</h><h>affine</h></idx>
    </p>

    <example xml:id="example-crypt-affine-crypt" permid="Mks">
      <p permid="egS">
        Let us consider the affine cryptosystem <m>f(p) = ap + b \bmod 26</m>.
        For this cryptosystem to work we must choose an <m>a \in {\mathbb Z}_{26}</m> that is invertible.
        This is only possible if <m>\gcd(a, 26) = 1</m>.
        Recognizing this fact,
        we will let <m>a = 5</m> since <m>\gcd(5, 26) = 1</m>.
        It is easy to see that <m>a^{-1} = 21</m>.
        Therefore, we can take our encryption function to be <m>f(p) = 5p + 3 \bmod 26</m>.
        Thus, ALGEBRA is encoded as <m>3, 6, 7, 23, 8, 10, 3</m>,
        or DGHXIKD. The decryption function will be
        <me permid="tEl">
          f^{-1}(p) = 21 p - 21 \cdot 3 \bmod 26 = 21 p + 15 \bmod 26
        </me>.
      </p>
    </example>

    <p permid="Edq">
      A cryptosystem would be more secure if a ciphertext letter could represent more than one plaintext letter.
      To give an example of this type of cryptosystem,
      called a <term>polyalphabetic cryptosystem</term>,<idx><h>Cryptosystem</h><h>polyalphabetic</h></idx> we will generalize affine codes by using matrices.
      The idea works roughly the same as before;
      however, instead of encrypting one letter at a time we will encrypt pairs of letters.
      We can store a pair of letters <m>p_1</m> and <m>p_2</m> in a vector
      <me permid="ZLu">
        {\mathbf p} = 
        \begin{pmatrix}
        p_1 \\ p_2
        \end{pmatrix}
      </me>.
      Let <m>A</m> be a <m>2 \times 2</m> invertible matrix with entries in <m>{\mathbb Z}_{26}</m>.
      We can define an encoding function by
      <me permid="FSD">
        f({\mathbf p}) = A {\mathbf p} + {\mathbf b}
      </me>,
      where <m>{\mathbf b}</m> is a fixed column vector and matrix operations are performed in <m>{\mathbb Z}_{26}</m>.
      The decoding function must be
      <me permid="lZM">
        f^{-1}({\mathbf p}) = A^{-1} {\mathbf p} - A^{-1} {\mathbf b}
      </me>.
    </p>

    <example xml:id="example-crypt-help" permid="srB">
      <p permid="Kob">
        Suppose that we wish to encode the word HELP. The corresponding digit string is <m>7, 4, 11, 15</m>.
        If
        <me permid="SgV">
          A =
          \begin{pmatrix}
          3 &amp; 5 \\
          1 &amp; 2
          \end{pmatrix}
        </me>,
        then
        <me permid="yoe">
          A^{-1} 
          =
          \begin{pmatrix}
          2 &amp; 21 \\
          25 &amp; 3
          \end{pmatrix}
        </me>.
        If <m>{\mathbf b} = ( 2, 2)^\transpose</m>,
        then our message is encrypted as RRGR. The encrypted letter R represents more than one plaintext letter.
      </p>
    </example>

    <p permid="kkz">
      Frequency analysis can still be performed on a polyalphabetic cryptosystem,
      because we have a good understanding of how pairs of letters appear in the English language.
      The pair <em>th</em> appears quite often;
      the pair <em>qz</em> never appears.
      To avoid decryption by a third party,
      we must use a larger matrix than the one we used in <xref ref="example-crypt-help"/>.
    </p>
        <!-- TWJ 4/7/2010 Need to resolve this reference -->
  </section>

  <section xml:id="section-public-key-crypt" permid="wrA">
    <title>Public Key Cryptography</title>
    <introduction permid="EFT">
      <p permid="vfd">
        If traditional cryptosystems are used,
        anyone who knows enough to encode a message will also know enough to decode an intercepted message.
        In 1976, W. Diffie
            <idx><h>Diffie, W.</h></idx>
        and M. Hellman
            <idx><h>Hellman, M.</h></idx>
        proposed public key cryptography,
        which is based on the observation that the encryption and decryption procedures need not have the same key.
        This removes the requirement that the encoding key be kept secret.
        The encoding function <m>f</m> must be relatively easy to compute,
        but <m>f^{-1}</m> must be extremely difficult to compute without some additional information,
        so that someone who knows only the encrypting key cannot find the decrypting key without prohibitive computation.
        It is interesting to note that to date,
        no system has been proposed that has been proven to be
        <q>one-way;</q> that is,
        for any existing public key cryptosystem,
        it has never been shown to be computationally prohibitive to decode messages with only knowledge of the encoding key.
      </p>
    </introduction>

    <subsection xml:id="crypt-subsection-rsa" permid="aJw">
      <title>The <acro>RSA</acro> Cryptosystem</title>
      <p permid="rfe">
        The <acro>RSA</acro> cryptosystem introduced by R. Rivest,
            <idx><h>Rivest, R.</h></idx>
        A. Shamir,
            <idx><h>Shamir, A.</h></idx>
        and L. Adleman
            <idx><h>Adleman, L.</h></idx>
        in 1978, is based on the difficulty of factoring large numbers.
        Though it is not a difficult task to find two large random primes and multiply them together,
        factoring a 150-digit number that is the product of two large primes would take 100 million computers operating at 10 million instructions per second about 50 million years under the fastest algorithms available in the early 1990s.
        Although the algorithms have improved,
        factoring a number that is a product of two large primes is still computationally prohibitive.
      </p>

      <p permid="Xmn">
        The <acro>RSA</acro> cryptosystem<idx><h><acro>RSA</acro> cryptosystem</h></idx><idx><h>Cryptosystem</h><h><acro>RSA</acro></h></idx> works as follows.
        Suppose that we choose two random 150-digit prime numbers <m>p</m> and <m>q</m>.
        Next, we compute the product <m>n= pq</m> and also compute <m>\phi(n) = m = (p - 1)(q-1)</m>,
        where <m>\phi</m> is the Euler <m>\phi</m>-function.
        Now we start choosing random integers <m>E</m> until we find one that is relatively prime to <m>m</m>;
        that is, we choose <m>E</m> such that <m>\gcd(E, m) = 1</m>.
        Using the Euclidean algorithm,
        we can find a number <m>D</m> such that <m>DE \equiv 1 \pmod{m}</m>.
        The numbers <m>n</m> and <m>E</m> are now made public.
      </p>

      <p permid="Dtw">
        Suppose now that person B (Bob) wishes to send person A (Alice) a message over a public line.
        Since <m>E</m> and <m>n</m> are known to everyone,
        anyone can encode messages.
        Bob first digitizes the message according to some scheme,
        say <m>\text{A} = 00, \text{B} = 02, \ldots, \text{Z}= 25</m>.
        If necessary,
        he will break the message into pieces such that each piece is a positive integer less than <m>n</m>.
        Suppose <m>x</m> is one of the pieces.
        Bob forms the number <m>y = x^E \mod n</m> and sends <m>y</m> to Alice.
        For Alice to recover <m>x</m>,
        she need only compute <m>x = y^D \bmod n</m>.
        Only Alice knows <m>D</m>.
      </p>

      <example xml:id="example-crypt-rsa" permid="IFS">
        <p permid="qvk">
          Before exploring the theory behind the <acro>RSA</acro> cryptosystem or attempting to use large integers,
          we will use some small integers just to see that the system does indeed work.
          Suppose that we wish to send some message,
          which when digitized is <m>25</m>.
          Let <m>p = 23</m> and <m>q = 29</m>.
          Then
          <me permid="evn">
            n = pq = 667
          </me>
          and
          <me permid="KCw">
            \phi(n) = m = (p - 1)(q - 1) = 616
          </me>.
          We can let <m>E = 487</m>, since <m>\gcd(616, 487) = 1</m>.
          The encoded message is computed to be
          <me permid="qJF">
            25^{487} \bmod 667 = 169
          </me>.
          This computation can be reasonably done by using the method of repeated squares as described in the following section.
          Using the Euclidean algorithm,
          we determine that <m>191 E = 1 + 151 m</m>;
          therefore, the decrypting key is <m>(n, D) = ( 667, 191)</m>.
          We can recover the original message by calculating
          <me permid="WQO">
            169^{191} \bmod 667 = 25
          </me>.
        </p>
      </example>
            <!-- Message changed from 23 to 25 so that it does not match p.  Suggested by R. Beezer. -->
            <!-- TWJ - 12/19/2011 -->
      <p permid="jAF">
        Now let us examine why the <acro>RSA</acro> cryptosystem works.
        We know that <m>DE \equiv 1 \pmod{ m}</m>;
        hence, there exists a <m>k</m> such that
        <me permid="CXX">
          DE = km + 1 = k \phi(n) + 1
        </me>.
        There are two cases to consider.
        In the first case assume that <m>\gcd(x, n) = 1</m>.
        Then by <xref ref="theorem-eulers_theorem"/>,
        <me permid="jfg">
          y^D = (x^E)^D = x^{DE} = x^{km + 1} = (x^{\phi(n)})^k x = (1)^k x = x \bmod n
        </me>.
        So we see that Alice recovers the original message <m>x</m> when she computes <m>y^D \bmod n</m>.
      </p>

      <p permid="PHO">
        For the other case, assume that <m>\gcd(x, n) \neq 1</m>.
        Since <m>n = pq</m> and <m>x \lt n</m>,
        we know <m>x</m> is a multiple of <m>p</m> or a multiple of <m>q</m>,
        but not both.
        We will describe the first possibility only,
        since the second is entirely similar.
        There is then an integer <m>r</m>,
        with <m>r \lt q</m> and <m>x = rp</m>.
        Note that we have <m>\gcd(x, q) = 1</m> and that <m>m=\phi(n)=(p - 1)(q - 1)=\phi(p)\phi(q)</m>.
        Then, using <xref ref="theorem-eulers_theorem"/>, but now mod <m>q</m>,
        <me permid="Pmp">
          x^{km} = x^{k\phi(p)\phi(q)} = (x^{\phi(q)})^{k\phi(p)} = (1)^{k\phi(p)} = 1 \bmod q
        </me>.
        So there is an integer <m>t</m> such that <m>x^{km}=1 + tq</m>.
        Thus, Alice also recovers the message in this case,
        <me permid="vty">
          y^D = x^{km + 1} = x^{km} x = (1 + tq) x = x + tq(rp) = x + trn = x \bmod n
        </me>.
      </p>
            <!-- Demonstration expanded to two cases.  Suggested by Kevin Halasz. -->
            <!-- RAB - 12/30/2011 -->
      <p permid="vOX">
        We can now ask how one would go about breaking the <acro>RSA</acro> cryptosystem.
        To find <m>D</m> given <m>n</m> and <m>E</m>,
        we simply need to factor <m>n</m> and solve for <m>D</m> by using the Euclidean algorithm.
        If we had known that <m>667 = 23 \cdot 29</m> in <xref ref="example-crypt-rsa"/>, we could have recovered <m>D</m>.
      </p>
    </subsection>

    <subsection xml:id="crypt-subsection-message-verification" permid="GQF">
      <title>Message Verification</title>
      <p permid="bWg">
        There is a problem of message verification in public key cryptosystems.
        Since the encoding key is public knowledge,
        anyone has the ability to send an encoded message.
        If Alice receives a message from Bob,
        she would like to be able to verify that it was Bob who actually sent the message.
        Suppose that Bob's encrypting key is
        <m>(n', E')</m> and his decrypting key is <m>(n', D')</m>.
        Also, suppose that Alice's encrypting key is <m>(n, E)</m> and her decrypting key is <m>(n, D)</m>.
        Since encryption keys are public information,
        they can exchange coded messages at their convenience.
        Bob wishes to assure Alice that the message he is sending is authentic.
        Before Bob sends the message <m>x</m> to Alice,
        he decrypts  <m>x</m> with his own key:
        <me permid="bAH">
          x' = x ^{D'} \bmod n'
        </me>.
        Anyone can change <m>x'</m> back to <m>x</m> just by encryption,
        but only Bob has the ability to form <m>x'</m>.
        Now Bob encrypts <m>x'</m> with Alice's encryption key to form
        <me permid="HHQ">
          y' = {x'}^E  \bmod n
        </me>,
        a message that only Alice can decode.
        Alice decodes the message and then encodes the result with Bob's key to read the original message,
        a message that could have only been sent by Bob.
      </p>
    </subsection>

    <subsection xml:id="crypt-subsection-historical-note" permid="mXO">
      <title>Historical Note</title>
      <p permid="Idp">
        Encrypting secret messages goes as far back as ancient Greece and Rome.
        As we know, Julius Caesar used a simple shift code to send and receive messages.
        However, the formal study of encoding and decoding messages probably began with the Arabs in the 1400s.
        In the fifteenth and sixteenth centuries mathematicians such as Alberti and Viete discovered that monoalphabetic cryptosystems offered no real security.
        In the 1800s, F. W. Kasiski established methods for breaking ciphers in which a ciphertext letter can represent more than one plaintext letter,
        if the same key was used several times.
        This discovery led to the use of cryptosystems with keys that were used only a single time.
        Cryptography was placed on firm mathematical foundations by such people as W. Friedman and L. Hill in the early part of the twentieth century.
      </p>

      <p permid="oky">
        The period after World War I saw the development of special-purpose machines for encrypting and decrypting messages,
        and mathematicians were very active in cryptography during World War II. Efforts to penetrate the cryptosystems of the Axis nations were organized in England and in the United States by such notable mathematicians as Alan Turing and A. A. Albert.
        The Allies gained a tremendous advantage in World War II by breaking the ciphers produced by the German Enigma machine and the Japanese Purple ciphers.
      </p>

      <p permid="UrH">
        By the 1970s, interest in commercial cryptography had begun to take hold.
        There was a growing need to protect banking transactions,
        computer data, and electronic mail.
        In the early 1970s, <acro>IBM</acro> developed and implemented <acro>LUZIFER</acro>,
        the forerunner of the National Bureau of Standards' Data Encryption Standard (DES).
      </p>

      <p permid="AyQ">
        The concept of a public key cryptosystem,
        due to Diffie and Hellman, is very recent (1976).
        It was further developed by Rivest, Shamir,
        and Adleman with the <acro>RSA</acro> cryptosystem (1978).
        It is not known how secure any of these systems are.
        The trapdoor knapsack cryptosystem,
        developed by Merkle and Hellman, has been broken.
        It is still an open question whether or not the <acro>RSA</acro> system can be broken.
        In 1991, <acro>RSA</acro> Laboratories published a list of semiprimes
        (numbers with exactly two prime factors)
        with a cash prize for whoever was able to provide a factorization
        (<url href="http://www.emc.com/emc-plus/rsa-labs/historical/the-rsa-challenge-numbers.htm">http://www.emc.com/emc-plus/rsa-labs/historical/the-rsa-challenge-numbers.htm</url>).
        Although the challenge ended in 2007,
        many of these numbers have not yet been factored.
      </p>

      <p permid="gFZ">
        There been a great deal of controversy about research in cryptography and cryptography itself.
        In 1929, when Henry Stimson, Secretary of State under Herbert Hoover,
        dismissed the Black Chamber
        (the State Department's cryptography division)
        on the ethical grounds that <q>gentlemen do not read each other's mail.</q>
        During the last two decades of the twentieth century,
        the National Security Agency wanted to keep information about cryptography secret,
        whereas the academic community fought for the right to publish basic research.
        Currently, research in mathematical cryptography and computational number theory is very active,
        and mathematicians are free to publish their results in these areas.
      </p>
    </subsection>

  </section>
  
  <xi:include href="worksheets/crypto-lab.ptx" />
  
    <section xml:id="section-method-of-repeated-squares" permid="YOj">
      <title>The Method of Repeated Squares</title>
      
      <p permid="Vrn">
        The method of repeated squares will prove to be a very useful tool in cryptography.
        To encode and decode messages in a reasonable manner under this scheme,
        it is necessary to be able to quickly compute large powers of integers mod <m>n</m>.
      </p>
      <p permid="cVM">
        Computing large powers can be very time-consuming.
        Just as anyone can compute <m>2^2</m> or <m>2^8</m>,
        everyone knows how to compute
        <me permid="JMP">
          2^{2^{1{,}000{,}000} }
        </me>.
        However, such numbers are so large that we do not want to attempt the calculations;
        moreover, past a certain point the computations would not be feasible even if we had every computer in the world at our disposal.
        Even writing down the decimal representation of a very large number may not be reasonable.
        It could be thousands or even millions of digits long.
        However, if we could compute something like
        <me permid="pTY">
          2^{37{,}398{,}332 } \pmod{ 46{,}389}
        </me>,
        we could very easily write the result down since it would be a number between <m>0</m> and <m>46{,}388</m>.
        If we want to compute powers modulo <m>n</m> quickly and efficiently,
        we will have to be clever.<fn>
        The results in this section are needed only in <xref ref="crypt"/>
        </fn></p>

      <p permid="JcV">
        The first thing to notice is that any number <m>a</m> can be written as the sum of distinct powers of <m>2</m>;
        that is, we can write
        <me permid="Wbh">
          a = 2^{k_1} + 2^{k_2} + \cdots + 2^{k_n}
        </me>,
        where <m>k_1 \lt k_2 \lt \cdots \lt k_n</m>.
        This is just the binary representation of <m>a</m>.
        For example, the binary representation of 57 is 111001,
        since we can write <m>57 = 2^0 + 2^3 + 2^4 + 2^5</m>.
      </p>

      <p permid="pke">
        The laws of exponents still work in <m>{\mathbb Z}_n</m>;
        that is, if <m>b \equiv a^x \pmod{ n}</m> and <m>c \equiv a^y \pmod{ n}</m>,
        then <m>bc \equiv a^{x+y} \pmod{ n}</m>.
        We can compute <m>a^{2^k} \pmod{ n}</m> in <m>k</m> multiplications by computing
        <md permid="Ciq">
          <mrow>a^{2^0} \pmod{ n}</mrow>
          <mrow>a^{2^1} \pmod{ n }</mrow>
          <mrow>\vdots</mrow>
          <mrow>a^{2^k} \pmod{ n}</mrow>
        </md>.
        Each step involves squaring the answer obtained in the previous step,
        dividing by <m>n</m>, and taking the remainder.
      </p>

      <example xml:id="example-cyclic-repeated-squares" permid="jBJ">
        <p permid="rQp">
          We will compute <m>271^{321} \pmod{ 481}</m>.
          Notice that
          <me permid="ipz">
            321 = 2^0 +2^6 + 2^8;
          </me>
          hence, computing <m>271^{ 321} \pmod{ 481}</m> is the same as computing
          <me permid="OwI">
            271^{ 2^0 +2^6 + 2^8 } \equiv 271^{ 2^0 } \cdot 271^{2^6 } \cdot 271^{ 2^8 } \pmod{ 481}
          </me>.
          So it will suffice to compute
          <m>271^{ 2^i } \pmod{ 481}</m> where <m>i = 0, 6, 8</m>.
          It is very easy to see that
          <me permid="uDR">
            271^{ 2^1}  = 73{,}441 \equiv 329 \pmod{ 481}
          </me>.
          We can square this result to obtain a value for <m>271^{ 2^2} \pmod{481}</m>:
          <md permid="mZs">
            <mrow>271^{ 2^2}  &amp; \equiv (271^{ 2^1})^2 \pmod{ 481}</mrow>
            <mrow>&amp; \equiv (329)^2 \pmod{481}</mrow>
            <mrow>&amp; \equiv 108{,}241 \pmod{481}</mrow>
            <mrow>&amp; \equiv 16 \pmod{481}</mrow>
          </md>.
          We are using the fact that <m>(a^{2^n})^2  \equiv a^{2 \cdot 2^n} \equiv a^{ 2^{n+1} } \pmod{ n}</m>.
          Continuing, we can calculate
          <me permid="aLa">
            271^{ 2^6 } \equiv 419 \pmod{481}
          </me>
          and
          <me permid="GSj">
            271^{ 2^8 }  \equiv 16 \pmod{481}
          </me>.
          Therefore,
          <md permid="TgB">
            <mrow>271^{ 321} &amp; \equiv 271^{ 2^0 +2^6 + 2^8 } \pmod{481}</mrow>
            <mrow>&amp; \equiv 271^{ 2^0 } \cdot 271^{ 2^6 } \cdot 271^{ 2^8 } \pmod{481}</mrow>
            <mrow>&amp; \equiv 271 \cdot 419 \cdot 16 \pmod{ 481}</mrow>
            <mrow>&amp; \equiv 1{,}816{,}784 \pmod{ 481}</mrow>
            <mrow>&amp; \equiv 47 \pmod{ 481}</mrow>
          </md>.
        </p>
      </example>
          <!-- Reformatted example.  TWJ 2/5/2013 -->



    </section>
    <!-- Exercises with Solutions  -->
    <!-- File: crypt.xml  -->
    <!-- Title: Introduction to Cryptography -->
  <exercises xml:id="exercises-crypt" filenamebase="crypt" permid="rHH">
    <title>Exercises</title>
    <exercise number="1" permid="oNb">
      <statement>
        <p permid="Htv">
          Encode <c>IXLOVEXMATH</c>using the cryptosystem in <xref ref="example-crypt-caesar"/>.
        </p>
      </statement>
      <hint permid="xbu">
        <p permid="hby">
          <c>LAORYHAPDWK</c>
        </p>
      </hint>
    </exercise>

    <exercise number="2" permid="UUk">
      <statement>
        <p permid="nAE">
          Decode <c>ZLOOA WKLVA EHARQ WKHA ILQDO</c>,
          which was encoded using the cryptosystem in <xref ref="example-crypt-caesar"/>.
        </p>
      </statement>
    </exercise>

    <exercise number="3" permid="Bbt">
      <statement>
        <p permid="THN">
          Assuming that monoalphabetic code was used to encode the following secret message,
          what was the original message?
        </p>

            <pre>
            APHUO EGEHP PEXOV FKEUH CKVUE CHKVE APHUO
            EGEHU EXOVL EXDKT VGEFT EHFKE UHCKF TZEXO
            VEZDT TVKUE XOVKV ENOHK ZFTEH TEHKQ LEROF
            PVEHP PEXOV ERYKP GERYT GVKEG XDRTE RGAGA</pre>

        <p permid="zOW">
          What is the significance of this message in the history of cryptography?
        </p>
      </statement>
      <hint permid="pwV">
        <p permid="NiH">
          Hint: <c>V = E</c>, <c>E = X</c>
          (also used for spaces and punctuation),
          <c>K = R</c>.
        </p>
      </hint>
    </exercise>

    <exercise number="4" permid="hiC">
      <statement>
        <p permid="fWf">
          What is the total number of possible monoalphabetic cryptosystems?
          How secure are such cryptosystems?
        </p>
      </statement>
      <hint permid="BLn">
        <p permid="tpQ">
          <m>26! - 1</m>
        </p>
      </hint>
    </exercise>

    <exercise number="5" permid="NpL">
      <statement>
        <p permid="Mdo">
          Prove that a <m>2 \times 2</m> matrix <m>A</m> with entries in
          <m>{\mathbb Z}_{26}</m> is invertible if and only if <m>\gcd( \det(A), 26 ) = 1</m>.
        </p>
      </statement>
    </exercise>

    <exercise number="6" permid="twU">
      <statement>
        <p permid="skx">
          Given the matrix
          <me permid="Adr">
            A =
            \begin{pmatrix}
            3 &amp; 4 \\
            2 &amp; 3
            \end{pmatrix}
          </me>,
          use the encryption function
          <m>f({\mathbf p}) = A {\mathbf p} + {\mathbf b}</m> to encode the message <c>CRYPTOLOGY</c>,
          where <m>{\mathbf b} = ( 2, 5)^\transpose</m>.
          What is the decoding function?
        </p>
      </statement>
    </exercise>

    <exercise number="7" xml:id="exercise-crypt-rsa" permid="ZEd">
      <statement>
        <p permid="YrG">
          Encrypt each of the following <acro>RSA</acro> messages <m>x</m> so that <m>x</m> is divided into blocks of integers of length <m>2</m>;
          that is, if <m>x = 142528</m>,
          encode <m>14</m>, <m>25</m>, and <m>28</m> separately.

          <ol permid="UyL">
            <li permid="FpN">
              <p permid="mgQ">
                <m>n = 3551, E = 629, x = 31</m>
              </p>
            </li>

            <li permid="lwW">
              <p permid="SnZ">
                <m>n = 2257, E = 47, x = 23</m>
              </p>
            </li>

            <li permid="REf">
              <p permid="yvi">
                <m>n = 120979, E = 13251, x = 142371</m>
              </p>
            </li>

            <li permid="xLo">
              <p permid="eCr">
                <m>n = 45629, E = 781, x = 231561</m>
              </p>
            </li>
          </ol>
        </p>
      </statement>
      <hint permid="anX">
        <p permid="ZwZ">
          (a) <m>2791</m>; (c) <m>112135 25032 442</m>.
        </p>
      </hint>
    </exercise>

    <exercise number="8" permid="FLm">
      <statement>
        <p permid="EyP">
          Compute the decoding key <m>D</m> for each of the encoding keys in <xref ref="exercise-crypt-rsa"/>.
        </p>
      </statement>
    </exercise>

    <exercise number="9" permid="lSv">
      <statement>
        <p permid="kFY">
          Decrypt each of the following <acro>RSA</acro> messages <m>y</m>.

          <ol permid="AFU">
            <li permid="Cvh">
              <p permid="jmk">
                <m>n = 3551, D = 1997, y = 2791</m>
              </p>
            </li>

            <li permid="iCq">
              <p permid="Ptt">
                <m>n = 5893, D = 81, y = 34</m>
              </p>
            </li>

            <li permid="OJz">
              <p permid="vAC">
                <m>n = 120979, D = 27331, y = 112135</m>
              </p>
            </li>

            <li permid="uQI">
              <p permid="bHL">
                <m>n = 79403, D = 671, y = 129381</m>
              </p>
            </li>
          </ol>
        </p>
      </statement>
      <hint permid="SJy">
        <p permid="FEi">
          (a) <m>31</m> (c) <m>14</m>.
        </p>
      </hint>
    </exercise>

    <exercise number="10" permid="RZE">
      <statement>
        <p permid="QNh">
          For each of the following encryption keys <m>(n, E)</m> in the <acro>RSA</acro> cryptosystem,
          compute <m>D</m>.

          <ol permid="gNd">
            <li permid="zAB">
              <p permid="grE">
                <m>(n, E) = (451, 231)</m>
              </p>
            </li>

            <li permid="fHK">
              <p permid="MyN">
                <m>(n, E) = (3053, 1921)</m>
              </p>
            </li>

            <li permid="LOT">
              <p permid="sFW">
                <m>(n, E) = (37986733, 12371)</m>
              </p>
            </li>

            <li permid="rWc">
              <p permid="YNf">
                <m>(n, E) = (16394854313, 34578451)</m>
              </p>
            </li>
          </ol>
        </p>
      </statement>
      <hint permid="eXQ">
        <p permid="lLr">
          (a) <m>n = 11 \cdot 41</m>; (c) <m>n = 8779 \cdot 4327</m>.
        </p>
      </hint>
    </exercise>

    <exercise number="11" permid="ygN">
      <statement>
        <p permid="wUq">
          Encrypted messages are often divided into blocks of <m>n</m> letters.
          A message such as <c>THE WORLD WONDERS WHY</c>might be encrypted as <c>JIW OCFRJ LPOEVYQ IOC</c>but sent as <c>JIW OCF RJL POE VYQ IOC</c>.
          What are the advantages of using blocks of <m>n</m> letters?
        </p>
      </statement>
    </exercise>

    <exercise number="12" permid="enW">
      <statement>
        <p permid="dbz">
          Find integers <m>n</m>, <m>E</m>, and <m>X</m> such that
          <me permid="syS">
            X^E \equiv X \pmod{n}
          </me>.
          Is this a potential problem in the <acro>RSA</acro> cryptosystem?
        </p>
      </statement>
    </exercise>

    <exercise number="13" permid="Kvf">
      <statement>
        <p permid="JiI">
          Every person in the class should construct an <acro>RSA</acro> cryptosystem using primes that are <m>10</m> to <m>15</m> digits long.
          Hand in <m>(n, E)</m> and an encoded message.
          Keep <m>D</m> secret.
          See if you can break one another's codes.
        </p>
      </statement>
    </exercise>

  </exercises>
  <exercises xml:id="crypt-exercises-additional" permid="XOQ">
    <title>Additional Exercises: Primality and Factoring</title>
    <p permid="nff">
      In the <acro>RSA</acro> cryptosystem it is important to be able to find large prime numbers easily.
      Also, this cryptosystem is not secure if we can factor a composite number that is the product of two large primes.
      The solutions to both of these problems are quite easy.
      To find out if a number <m>n</m> is prime or to factor <m>n</m>,
      we can use trial division.
      We simply divide <m>n</m> by <m>d = 2, 3, \ldots, \sqrt{n}</m>.
      Either a factorization will be obtained,
      or <m>n</m> is prime if no <m>d</m> divides <m>n</m>.
      The problem is that such a computation is prohibitively time-consuming if <m>n</m> is very large.
    </p>

    <exercise permid="WJx">
      <statement>
        <p permid="ppR">
          A better algorithm for factoring odd positive integers is
          <term>Fermat's factorization algorithm</term>.
              <idx><h>Fermat's factorizationalgorithm</h></idx>
        </p>

        <ol permid="MUm">
          <li permid="wFV">
            <p permid="dwY">
              Let <m>n= ab</m> be an odd composite number.
              Prove that <m>n</m> can be written as the difference of two perfect squares:
              <me permid="YGb">
                n = x^2 - y^2 = (x - y)(x + y)
              </me>.
              Consequently,
              a positive odd integer can be factored exactly when we can find integers <m>x</m> and <m>y</m> such that <m>n = x^2 - y^2</m>.
            </p>
          </li>

          <li permid="cNe">
            <p permid="JEh">
              Write a program to implement the following factorization algorithm based on the observation in part (a).
              The expression <c>ceiling(sqrt(n))</c>means the smallest integer greater than or equal to the square root of <m>n</m>.
              Write another program to do factorization using trial division and compare the speed of the two algorithms.
              Which algorithm is faster and why?
            </p>
          </li>
        </ol>

        <sidebyside permid="qCo">

            <program>
                <input>
                    x := ceiling(sqrt(n))
                    y := 1

                    1 : while x^2 - y^2 &gt; n do
                        y := y + 1

                    if x^2 - y^2 &lt; n then
                        x := x + 1
                        y := 1
                        goto 1
                    else if x^2 - y^2 = 0 then
                        a := x - y
                        b := x + y
                        write n = a * b
                </input>
            </program>
        </sidebyside>
      </statement>
    </exercise>

    <exercise permid="CQG">
      <title>Primality Testing</title>
      <statement>
        <p permid="Vxa">
          Recall <xref ref="theorem-little-fermat">Fermat's Little Theorem</xref> from <xref ref="section-groups-lagrange"/>.
          Let <m>p</m> be prime with <m>\gcd(a, p) = 1</m>.
          Then <m>a^{p-1} \equiv 1 \pmod{p}</m>.
          We can use Fermat's Little Theorem as a screening test for primes.
          For example, <m>15</m> cannot be prime since
          <me permid="ENk">
            2^{15-1} \equiv 2^{14} \equiv 4 \pmod{15}
          </me>.
          However, <m>17</m> is a potential prime since
          <me permid="kUt">
            2^{17-1} \equiv 2^{16} \equiv 1 \pmod{17}
          </me>.
          We say that an odd composite number <m>n</m> is a <term>pseudoprime</term>
              <idx><h>Pseudoprime</h></idx>
          if
          <me permid="RbC">
            2^{n-1} \equiv 1 \pmod{n}
          </me>.
          Which of the following numbers are primes and which are pseudoprimes?

          <ol cols="3" permid="tbv">
            <li permid="IUn">
              <p permid="pLq">
                <m>342</m>
              </p>
            </li>

            <li permid="pbw">
              <p permid="VSz">
                <m>811</m>
              </p>
            </li>

            <li permid="ViF">
              <p permid="BZI">
                601
              </p>
            </li>

            <li permid="BpO">
              <p permid="igR">
                <m>561</m>
              </p>
            </li>

            <li permid="hwX">
              <p permid="Ooa">
                <m>771</m>
              </p>
            </li>

            <li permid="NEg">
              <p permid="uvj">
                <m>631</m>
              </p>
            </li>
          </ol>
        </p>
      </statement>
    </exercise>

    <exercise permid="iXP">
      <statement>
        <p permid="BEj">
          Let <m>n</m> be an odd composite number and <m>b</m> be a positive integer such that <m>\gcd(b, n) = 1</m>.
          If <m>b^{n-1} \equiv 1 \pmod{n}</m>,
          then <m>n</m> is a <term>pseudoprime base</term> <m>b</m>.
          Show that <m>341</m> is a pseudoprime base <m>2</m> but not a pseudoprime base <m>3</m>.
        </p>
      </statement>
    </exercise>

    <exercise permid="PeY">
      <statement>
        <p permid="hLs">
          Write a program to determine all primes less than <m>2000</m> using trial division.
          Write a second program that will determine all numbers less than <m>2000</m> that are either primes or pseudoprimes.
          Compare the speed of the two programs.
          How many pseudoprimes are there below <m>2000</m>?
        </p>

        <p permid="NSB">
          There exist composite numbers that are pseudoprimes for all bases to which they are relatively prime.
          These numbers are called <term>Carmichael numbers</term>.
              <idx><h>Carmichael numbers</h></idx>
          The first Carmichael number is <m>561 = 3 \cdot 11 \cdot 17</m>.
          In 1992, Alford, Granville,
          and Pomerance proved that there are an infinite number of Carmichael numbers [4]. However, Carmichael numbers are very rare.
          There are only 2163 Carmichael numbers less than <m>25 \times 10^9</m>.
          For more sophisticated primality tests, see [1], [6], or [7].
        </p>
      </statement>
    </exercise>

  </exercises>

  <references xml:id="crypt-references" permid="yqf">
    <title>References and Suggested Readings</title>
    <biblio type="raw" permid="exo">
<!-- was [1] -->
      Bressoud, D. M.
      <title>Factorization and Primality Testing</title>
      . Springer-Verlag, New York, 1989.
    </biblio>

    <biblio type="raw" permid="KEx">
<!-- was [2] -->
      Diffie, W. and Hellman, M. E. <q>New Directions in Cryptography,</q>
      <title>IEEE Trans. Inform. Theory</title>
      <volume>22</volume>
      (1976), 644<ndash/>54.
    </biblio>
        <!-- Title corrected.  Suggested by R. Beezer.  TWJ - 12/20/2011 -->
    <biblio type="raw" permid="qLG">
<!-- was [3] -->
      Gardner, M. <q>Mathematical games: A new kind of cipher that would take millions of years to break,</q>
      <title>Scientific American</title>
      <volume>237</volume>
      (1977), 120<ndash/>24.
    </biblio>

    <biblio type="raw" permid="WSP">
<!-- was [4] -->
      Granville, A. <q>Primality Testing and Carmichael Numbers,</q>
      <title>Notices of the American Mathematical Society</title>
      <volume>39</volume>
      (1992), 696<ndash/>700.
    </biblio>

    <biblio type="raw" permid="CZY">
<!-- was [5] -->
      Hellman, M. E. <q>The Mathematics of Public Key Cryptography,</q>
      <title>Scientific American</title>
      <volume>241</volume>
      (1979), 130<ndash/>39.
    </biblio>
        <!-- reference updated - TWJ 5/10/2010 -->
    <biblio type="raw" permid="jhh">
<!-- was [6] -->
      Koblitz, N.
      <title>A Course in Number Theory and Cryptography</title>
      . 2nd ed. Springer, New York, 1994.
    </biblio>

    <biblio type="raw" permid="Poq">
<!-- was [7] -->
      Pomerance, C., ed. <q>Cryptology and Computational Number Theory</q>,
      <title>Proceedings of Symposia in Applied Mathematics</title>
      <volume>42</volume>
      (1990) American Mathematical Society, Providence, RI.
    </biblio>

    <biblio type="raw" permid="vvz">
<!-- was [8] -->
      Rivest, R. L., Shamir, A., and Adleman, L., <q>A Method for Obtaining Signatures and Public-key Cryptosystems,</q>
      <title>Comm. ACM</title>
      <volume>21</volume>
      (1978), 120<ndash/>26.
    </biblio>
  </references>
 
</chapter>
